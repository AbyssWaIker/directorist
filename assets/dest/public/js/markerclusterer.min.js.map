{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/@babel/runtime/helpers/typeof/index.js","webpack:///./assets/src/js/map-scripts/markerclusterer.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_typeof","obj","iterator","constructor","MarkerClusterer","map","opt_markers","opt_options","this","extend","google","maps","OverlayView","map_","markers_","clusters_","sizes","styles_","cssClass_","ready_","options","gridSize_","minClusterSize_","maxZoom_","imagePath_","MARKER_CLUSTER_IMAGE_PATH_","imageExtension_","MARKER_CLUSTER_IMAGE_EXTENSION_","zoomOnClick_","undefined","averageCenter_","setupStyles_","setMap","prevZoom_","getZoom","that","event","addListener","zoom","resetViewport","redraw","length","addMarkers","Cluster","markerClusterer","markerClusterer_","getMap","getGridSize","getMinClusterSize","isAverageCenter","center_","bounds_","clusterIcon_","ClusterIcon","getStyles","cluster","styles","opt_padding","getMarkerClusterer","padding_","cluster_","div_","sums_","visible_","obj1","obj2","apply","onAdd","setReady_","draw","size","push","url","height","width","fitMapToMarkers","marker","markers","getMarkers","bounds","LatLngBounds","getPosition","fitBounds","setStyles","isZoomOnClick","getTotalMarkers","setMaxZoom","maxZoom","getMaxZoom","calculator_","numStyles","index","count","dv","parseInt","text","Math","min","setCalculator","calculator","getCalculator","opt_nodraw","pushMarkerTo_","isAdded","repaint","addMarker","removeMarker_","indexOf","splice","removeMarker","removed","removeMarkers","ready","createClusters_","getTotalClusters","setGridSize","setMinClusterSize","getExtendedBounds","projection","getProjection","tr","LatLng","getNorthEast","lat","lng","bl","getSouthWest","trPix","fromLatLngToDivPixel","x","y","blPix","ne","fromDivPixelToLatLng","sw","isMarkerInBounds_","contains","clearMarkers","opt_hide","remove","oldClusters","slice","window","setTimeout","distanceBetweenPoints_","p1","p2","dLat","PI","dLon","a","sin","cos","atan2","sqrt","addToClosestCluster_","distance","clusterToAddTo","center","getCenter","isMarkerInClusterBounds","mapBounds","getBounds","isMarkerAlreadyAdded","calculateBounds_","len","updateIcon","getSize","mz","hide","sums","setCenter","setSums","show","triggerClusterClick","trigger","document","createElement","pos","getPosFromLatLng_","style","cssText","createCss","innerHTML","className","getPanes","overlayMouseTarget","appendChild","addDomListener","latlng","width_","height_","top","left","display","onRemove","parentNode","removeChild","text_","index_","useStyle","max","url_","textColor_","anchor_","textSize_","backgroundPosition_","backgroundPosition","txtColor","txtSize","join"],"mappings":"aACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QAKfF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,oBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,GAIjBlC,EAAoBA,EAAoBmC,EAAI,I,kBClFrD,SAASC,EAAQC,GAiBf,MAdsB,mBAAXlB,QAAoD,iBAApBA,OAAOmB,UAChDnC,EAAOD,QAAUkC,EAAU,SAAiBC,GAC1C,cAAcA,GAGhBlC,EAAOD,QAAiB,QAAIC,EAAOD,QAASC,EAAOD,QAAQsB,YAAa,IAExErB,EAAOD,QAAUkC,EAAU,SAAiBC,GAC1C,OAAOA,GAAyB,mBAAXlB,QAAyBkB,EAAIE,cAAgBpB,QAAUkB,IAAQlB,OAAOa,UAAY,gBAAkBK,GAG3HlC,EAAOD,QAAiB,QAAIC,EAAOD,QAASC,EAAOD,QAAQsB,YAAa,GAGnEY,EAAQC,GAGjBlC,EAAOD,QAAUkC,EACjBjC,EAAOD,QAAiB,QAAIC,EAAOD,QAASC,EAAOD,QAAQsB,YAAa,G,+FCyCxE,SAASgB,EAAgBC,EAAKC,EAAaC,GAMvCC,KAAKC,OAAOL,EAAiBM,OAAOC,KAAKC,aACzCJ,KAAKK,KAAOR,EAMZG,KAAKM,SAAW,GAKhBN,KAAKO,UAAY,GAEjBP,KAAKQ,MAAQ,CAAC,GAAI,GAAI,GAAI,GAAI,IAK9BR,KAAKS,QAAU,GAKfT,KAAKU,UAAY,GAMjBV,KAAKW,QAAS,EAEd,IAAIC,EAAUb,GAAe,GAM7BC,KAAKa,UAAYD,EAAO,UAAgB,GAKxCZ,KAAKc,gBAAkBF,EAAO,oBAA0B,EAOxDZ,KAAKe,SAAWH,EAAO,SAAe,KAEtCZ,KAAKS,QAAUG,EAAO,QAAc,GAEpCZ,KAAKU,UAAYE,EAAO,UAAgB,KAMxCZ,KAAKgB,WAAaJ,EAAO,WACrBZ,KAAKiB,2BAMTjB,KAAKkB,gBAAkBN,EAAO,gBAC1BZ,KAAKmB,gCAMTnB,KAAKoB,cAAe,EAEUC,MAA1BT,EAAO,cACTZ,KAAKoB,aAAeR,EAAO,aAO7BZ,KAAKsB,gBAAiB,EAEUD,MAA5BT,EAAO,gBACTZ,KAAKsB,eAAiBV,EAAO,eAG/BZ,KAAKuB,eAELvB,KAAKwB,OAAO3B,GAMZG,KAAKyB,UAAYzB,KAAKK,KAAKqB,UAG3B,IAAIC,EAAO3B,KACXE,OAAOC,KAAKyB,MAAMC,YAAY7B,KAAKK,KAAM,gBAAgB,WACvD,IAAIyB,EAAOH,EAAKtB,KAAKqB,UAEjBC,EAAKF,WAAaK,IACpBH,EAAKF,UAAYK,EACjBH,EAAKI,oBAIT7B,OAAOC,KAAKyB,MAAMC,YAAY7B,KAAKK,KAAM,QAAQ,WAC/CsB,EAAKK,YAIHlC,GAAeA,EAAYmC,QAC7BjC,KAAKkC,WAAWpC,GAAa,GA+mBjC,SAASqC,EAAQC,GACfpC,KAAKqC,iBAAmBD,EACxBpC,KAAKK,KAAO+B,EAAgBE,SAC5BtC,KAAKa,UAAYuB,EAAgBG,cACjCvC,KAAKc,gBAAkBsB,EAAgBI,oBACvCxC,KAAKsB,eAAiBc,EAAgBK,kBACtCzC,KAAK0C,QAAU,KACf1C,KAAKM,SAAW,GAChBN,KAAK2C,QAAU,KACf3C,KAAK4C,aAAe,IAAIC,EAAY7C,KAAMoC,EAAgBU,YACtDV,EAAgBG,eAuNtB,SAASM,EAAYE,EAASC,EAAQC,GACpCF,EAAQG,qBAAqBjD,OAAO4C,EAAa3C,OAAOC,KAAKC,aAE7DJ,KAAKS,QAAUuC,EACfhD,KAAKmD,SAAWF,GAAe,EAC/BjD,KAAKoD,SAAWL,EAChB/C,KAAK0C,QAAU,KACf1C,KAAKK,KAAO0C,EAAQT,SACpBtC,KAAKqD,KAAO,KACZrD,KAAKsD,MAAQ,KACbtD,KAAKuD,UAAW,EAEhBvD,KAAKwB,OAAOxB,KAAKK,MAj1BnBT,EAAgBR,UAAU6B,2BACtB,0FAUJrB,EAAgBR,UAAU+B,gCAAkC,MAW5DvB,EAAgBR,UAAUa,OAAS,SAASuD,EAAMC,GAChD,OAAQ,SAASvE,GACf,IAAK,IAAIC,KAAYD,EAAOE,UAC1BY,KAAKZ,UAAUD,GAAYD,EAAOE,UAAUD,GAE9C,OAAOa,MACN0D,MAAMF,EAAM,CAACC,KAQlB7D,EAAgBR,UAAUuE,MAAQ,WAChC3D,KAAK4D,WAAU,IAOjBhE,EAAgBR,UAAUyE,KAAO,aAOjCjE,EAAgBR,UAAUmC,aAAe,WACvC,IAAIvB,KAAKS,QAAQwB,OAIjB,IAAK,IAAW6B,EAAPtG,EAAI,EAASsG,EAAO9D,KAAKQ,MAAMhD,GAAIA,IAC1CwC,KAAKS,QAAQsD,KAAK,CAChBC,IAAKhE,KAAKgB,YAAcxD,EAAI,GAAK,IAAMwC,KAAKkB,gBAC5C+C,OAAQH,EACRI,MAAOJ,KAQblE,EAAgBR,UAAU+E,gBAAkB,WAG1C,IAFA,IAEgBC,EAFZC,EAAUrE,KAAKsE,aACfC,EAAS,IAAIrE,OAAOC,KAAKqE,aACpBhH,EAAI,EAAW4G,EAASC,EAAQ7G,GAAIA,IAC3C+G,EAAOtE,OAAOmE,EAAOK,eAGvBzE,KAAKK,KAAKqE,UAAUH,IAStB3E,EAAgBR,UAAUuF,UAAY,SAAS3B,GAC7ChD,KAAKS,QAAUuC,GASjBpD,EAAgBR,UAAU0D,UAAY,WACpC,OAAO9C,KAAKS,SASdb,EAAgBR,UAAUwF,cAAgB,WACxC,OAAO5E,KAAKoB,cAQdxB,EAAgBR,UAAUqD,gBAAkB,WAC1C,OAAOzC,KAAKsB,gBASd1B,EAAgBR,UAAUkF,WAAa,WACrC,OAAOtE,KAAKM,UASdV,EAAgBR,UAAUyF,gBAAkB,WAC1C,OAAO7E,KAAKM,SAAS2B,QASvBrC,EAAgBR,UAAU0F,WAAa,SAASC,GAC9C/E,KAAKe,SAAWgE,GASlBnF,EAAgBR,UAAU4F,WAAa,WACrC,OAAOhF,KAAKe,UAYdnB,EAAgBR,UAAU6F,YAAc,SAASZ,EAASa,GAIxD,IAHA,IAAIC,EAAQ,EACRC,EAAQf,EAAQpC,OAChBoD,EAAKD,EACK,IAAPC,GACLA,EAAKC,SAASD,EAAK,GAAI,IACvBF,IAIF,MAAO,CACLI,KAAMH,EACND,MAHFA,EAAQK,KAAKC,IAAIN,EAAOD,KAgB1BtF,EAAgBR,UAAUsG,cAAgB,SAASC,GACjD3F,KAAKiF,YAAcU,GASrB/F,EAAgBR,UAAUwG,cAAgB,WACxC,OAAO5F,KAAKiF,aAUdrF,EAAgBR,UAAU8C,WAAa,SAASmC,EAASwB,GACvD,IAAK,IAAWzB,EAAP5G,EAAI,EAAW4G,EAASC,EAAQ7G,GAAIA,IAC3CwC,KAAK8F,cAAc1B,GAEhByB,GACH7F,KAAKgC,UAWTpC,EAAgBR,UAAU0G,cAAgB,SAAS1B,GAEjD,GADAA,EAAO2B,SAAU,EACb3B,EAAM,UAAe,CAGvB,IAAIzC,EAAO3B,KACXE,OAAOC,KAAKyB,MAAMC,YAAYuC,EAAQ,WAAW,WAC/CA,EAAO2B,SAAU,EACjBpE,EAAKqE,aAGThG,KAAKM,SAASyD,KAAKK,IAUrBxE,EAAgBR,UAAU6G,UAAY,SAAS7B,EAAQyB,GACrD7F,KAAK8F,cAAc1B,GACdyB,GACH7F,KAAKgC,UAYTpC,EAAgBR,UAAU8G,cAAgB,SAAS9B,GACjD,IAAIe,GAAS,EACb,GAAInF,KAAKM,SAAS6F,QAChBhB,EAAQnF,KAAKM,SAAS6F,QAAQ/B,QAE9B,IAAK,IAAWxG,EAAPJ,EAAI,EAAMI,EAAIoC,KAAKM,SAAS9C,GAAIA,IACvC,GAAII,GAAKwG,EAAQ,CACfe,EAAQ3H,EACR,MAKN,OAAc,GAAV2H,IAKJf,EAAO5C,OAAO,MAEdxB,KAAKM,SAAS8F,OAAOjB,EAAO,IAErB,IAWTvF,EAAgBR,UAAUiH,aAAe,SAASjC,EAAQyB,GACxD,IAAIS,EAAUtG,KAAKkG,cAAc9B,GAEjC,QAAKyB,IAAcS,KACjBtG,KAAK+B,gBACL/B,KAAKgC,UACE,IAaXpC,EAAgBR,UAAUmH,cAAgB,SAASlC,EAASwB,GAG1D,IAFA,IAEgBzB,EAFZkC,GAAU,EAEL9I,EAAI,EAAW4G,EAASC,EAAQ7G,GAAIA,IAAK,CAChD,IAAIc,EAAI0B,KAAKkG,cAAc9B,GAC3BkC,EAAUA,GAAWhI,EAGvB,IAAKuH,GAAcS,EAGjB,OAFAtG,KAAK+B,gBACL/B,KAAKgC,UACE,GAWXpC,EAAgBR,UAAUwE,UAAY,SAAS4C,GACxCxG,KAAKW,SACRX,KAAKW,OAAS6F,EACdxG,KAAKyG,oBAUT7G,EAAgBR,UAAUsH,iBAAmB,WAC3C,OAAO1G,KAAKO,UAAU0B,QASxBrC,EAAgBR,UAAUkD,OAAS,WACjC,OAAOtC,KAAKK,MASdT,EAAgBR,UAAUoC,OAAS,SAAS3B,GAC1CG,KAAKK,KAAOR,GASdD,EAAgBR,UAAUmD,YAAc,WACtC,OAAOvC,KAAKa,WASdjB,EAAgBR,UAAUuH,YAAc,SAAS7C,GAC/C9D,KAAKa,UAAYiD,GASnBlE,EAAgBR,UAAUoD,kBAAoB,WAC5C,OAAOxC,KAAKc,iBAQdlB,EAAgBR,UAAUwH,kBAAoB,SAAS9C,GACrD9D,KAAKc,gBAAkBgD,GAUzBlE,EAAgBR,UAAUyH,kBAAoB,SAAStC,GACrD,IAAIuC,EAAa9G,KAAK+G,gBAGlBC,EAAK,IAAI9G,OAAOC,KAAK8G,OAAO1C,EAAO2C,eAAeC,MAClD5C,EAAO2C,eAAeE,OACtBC,EAAK,IAAInH,OAAOC,KAAK8G,OAAO1C,EAAO+C,eAAeH,MAClD5C,EAAO+C,eAAeF,OAGtBG,EAAQT,EAAWU,qBAAqBR,GAC5CO,EAAME,GAAKzH,KAAKa,UAChB0G,EAAMG,GAAK1H,KAAKa,UAEhB,IAAI8G,EAAQb,EAAWU,qBAAqBH,GAC5CM,EAAMF,GAAKzH,KAAKa,UAChB8G,EAAMD,GAAK1H,KAAKa,UAGhB,IAAI+G,EAAKd,EAAWe,qBAAqBN,GACrCO,EAAKhB,EAAWe,qBAAqBF,GAMzC,OAHApD,EAAOtE,OAAO2H,GACdrD,EAAOtE,OAAO6H,GAEPvD,GAYT3E,EAAgBR,UAAU2I,kBAAoB,SAAS3D,EAAQG,GAC7D,OAAOA,EAAOyD,SAAS5D,EAAOK,gBAOhC7E,EAAgBR,UAAU6I,aAAe,WACvCjI,KAAK+B,eAAc,GAGnB/B,KAAKM,SAAW,IAQlBV,EAAgBR,UAAU2C,cAAgB,SAASmG,GAEjD,IAAK,IAAWnF,EAAPvF,EAAI,EAAYuF,EAAU/C,KAAKO,UAAU/C,GAAIA,IACpDuF,EAAQoF,SAIL,IAAW/D,EAAhB,IAAS5G,EAAI,EAAW4G,EAASpE,KAAKM,SAAS9C,GAAIA,IACjD4G,EAAO2B,SAAU,EACbmC,GACF9D,EAAO5C,OAAO,MAIlBxB,KAAKO,UAAY,IAMnBX,EAAgBR,UAAU4G,QAAU,WAClC,IAAIoC,EAAcpI,KAAKO,UAAU8H,QACjCrI,KAAKO,UAAU0B,OAAS,EACxBjC,KAAK+B,gBACL/B,KAAKgC,SAILsG,OAAOC,YAAW,WAChB,IAAK,IAAWxF,EAAPvF,EAAI,EAAYuF,EAAUqF,EAAY5K,GAAIA,IACjDuF,EAAQoF,WAET,IAOLvI,EAAgBR,UAAU4C,OAAS,WACjChC,KAAKyG,mBAaP7G,EAAgBR,UAAUoJ,uBAAyB,SAASC,EAAIC,GAC9D,IAAKD,IAAOC,EACV,OAAO,EAGT,IACIC,GAAQD,EAAGvB,MAAQsB,EAAGtB,OAAS3B,KAAKoD,GAAK,IACzCC,GAAQH,EAAGtB,MAAQqB,EAAGrB,OAAS5B,KAAKoD,GAAK,IACzCE,EAAItD,KAAKuD,IAAIJ,EAAO,GAAKnD,KAAKuD,IAAIJ,EAAO,GACzCnD,KAAKwD,IAAIP,EAAGtB,MAAQ3B,KAAKoD,GAAK,KAAOpD,KAAKwD,IAAIN,EAAGvB,MAAQ3B,KAAKoD,GAAK,KACnEpD,KAAKuD,IAAIF,EAAO,GAAKrD,KAAKuD,IAAIF,EAAO,GAGzC,OARQ,MAMA,EAAIrD,KAAKyD,MAAMzD,KAAK0D,KAAKJ,GAAItD,KAAK0D,KAAK,EAAIJ,MAYrDlJ,EAAgBR,UAAU+J,qBAAuB,SAAS/E,GAIxD,IAHA,IAiBMrB,EAjBFqG,EAAW,IACXC,EAAiB,KAEZ7L,GADC4G,EAAOK,cACJ,GAAY1B,EAAU/C,KAAKO,UAAU/C,GAAIA,IAAK,CACzD,IAAI8L,EAASvG,EAAQwG,YACrB,GAAID,EAAQ,CACV,IAAIxL,EAAIkC,KAAKwI,uBAAuBc,EAAQlF,EAAOK,eAC/C3G,EAAIsL,IACNA,EAAWtL,EACXuL,EAAiBtG,IAKnBsG,GAAkBA,EAAeG,wBAAwBpF,GAC3DiF,EAAepD,UAAU7B,KAErBrB,EAAU,IAAIZ,EAAQnC,OAClBiG,UAAU7B,GAClBpE,KAAKO,UAAUwD,KAAKhB,KAUxBnD,EAAgBR,UAAUqH,gBAAkB,WAC1C,GAAKzG,KAAKW,OAUV,IAJA,IAIgByD,EAJZqF,EAAY,IAAIvJ,OAAOC,KAAKqE,aAAaxE,KAAKK,KAAKqJ,YAAYpC,eAC/DtH,KAAKK,KAAKqJ,YAAYxC,gBACtB3C,EAASvE,KAAK6G,kBAAkB4C,GAE3BjM,EAAI,EAAW4G,EAASpE,KAAKM,SAAS9C,GAAIA,KAC5C4G,EAAO2B,SAAW/F,KAAK+H,kBAAkB3D,EAAQG,IACpDvE,KAAKmJ,qBAAqB/E,IAiChCjC,EAAQ/C,UAAUuK,qBAAuB,SAASvF,GAChD,GAAIpE,KAAKM,SAAS6F,QAChB,OAAyC,GAAlCnG,KAAKM,SAAS6F,QAAQ/B,GAE7B,IAAK,IAAWxG,EAAPJ,EAAI,EAAMI,EAAIoC,KAAKM,SAAS9C,GAAIA,IACvC,GAAII,GAAKwG,EACP,OAAO,EAIb,OAAO,GAUTjC,EAAQ/C,UAAU6G,UAAY,SAAS7B,GACrC,GAAIpE,KAAK2J,qBAAqBvF,GAC5B,OAAO,EAGT,GAAKpE,KAAK0C,SAIR,GAAI1C,KAAKsB,eAAgB,CACvB,IAAI7D,EAAIuC,KAAKM,SAAS2B,OAAS,EAC3BkF,GAAOnH,KAAK0C,QAAQyE,OAAS1J,EAAE,GAAK2G,EAAOK,cAAc0C,OAAS1J,EAClE2J,GAAOpH,KAAK0C,QAAQ0E,OAAS3J,EAAE,GAAK2G,EAAOK,cAAc2C,OAAS3J,EACtEuC,KAAK0C,QAAU,IAAIxC,OAAOC,KAAK8G,OAAOE,EAAKC,GAC3CpH,KAAK4J,yBARP5J,KAAK0C,QAAU0B,EAAOK,cACtBzE,KAAK4J,mBAWPxF,EAAO2B,SAAU,EACjB/F,KAAKM,SAASyD,KAAKK,GAEnB,IAAIyF,EAAM7J,KAAKM,SAAS2B,OAMxB,GALI4H,EAAM7J,KAAKc,iBAAmBsD,EAAO9B,UAAYtC,KAAKK,MAExD+D,EAAO5C,OAAOxB,KAAKK,MAGjBwJ,GAAO7J,KAAKc,gBAEd,IAAK,IAAItD,EAAI,EAAGA,EAAIqM,EAAKrM,IACvBwC,KAAKM,SAAS9C,GAAGgE,OAAO,MAS5B,OALIqI,GAAO7J,KAAKc,iBACdsD,EAAO5C,OAAO,MAGhBxB,KAAK8J,cACE,GAST3H,EAAQ/C,UAAU8D,mBAAqB,WACrC,OAAOlD,KAAKqC,kBASdF,EAAQ/C,UAAUsK,UAAY,WAG5B,IAFA,IAEgBtF,EAFZG,EAAS,IAAIrE,OAAOC,KAAKqE,aAAaxE,KAAK0C,QAAS1C,KAAK0C,SACzD2B,EAAUrE,KAAKsE,aACV9G,EAAI,EAAW4G,EAASC,EAAQ7G,GAAIA,IAC3C+G,EAAOtE,OAAOmE,EAAOK,eAEvB,OAAOF,GAOTpC,EAAQ/C,UAAU+I,OAAS,WACzBnI,KAAK4C,aAAauF,SAClBnI,KAAKM,SAAS2B,OAAS,SAChBjC,KAAKM,UASd6B,EAAQ/C,UAAU2K,QAAU,WAC1B,OAAO/J,KAAKM,SAAS2B,QASvBE,EAAQ/C,UAAUkF,WAAa,WAC7B,OAAOtE,KAAKM,UASd6B,EAAQ/C,UAAUmK,UAAY,WAC5B,OAAOvJ,KAAK0C,SASdP,EAAQ/C,UAAUwK,iBAAmB,WACnC,IAAIrF,EAAS,IAAIrE,OAAOC,KAAKqE,aAAaxE,KAAK0C,QAAS1C,KAAK0C,SAC7D1C,KAAK2C,QAAU3C,KAAKqC,iBAAiBwE,kBAAkBtC,IAUzDpC,EAAQ/C,UAAUoK,wBAA0B,SAASpF,GACnD,OAAOpE,KAAK2C,QAAQqF,SAAS5D,EAAOK,gBAStCtC,EAAQ/C,UAAUkD,OAAS,WACzB,OAAOtC,KAAKK,MAOd8B,EAAQ/C,UAAU0K,WAAa,WAC7B,IAAIhI,EAAO9B,KAAKK,KAAKqB,UACjBsI,EAAKhK,KAAKqC,iBAAiB2C,aAE/B,GAAIgF,GAAMlI,EAAOkI,EAEf,IAAK,IAAW5F,EAAP5G,EAAI,EAAW4G,EAASpE,KAAKM,SAAS9C,GAAIA,IACjD4G,EAAO5C,OAAOxB,KAAKK,WAKvB,GAAIL,KAAKM,SAAS2B,OAASjC,KAAKc,gBAE9Bd,KAAK4C,aAAaqH,WAFpB,CAMA,IAAI/E,EAAYlF,KAAKqC,iBAAiBS,YAAYb,OAC9CiI,EAAOlK,KAAKqC,iBAAiBuD,eAAtB5F,CAAsCA,KAAKM,SAAU4E,GAChElF,KAAK4C,aAAauH,UAAUnK,KAAK0C,SACjC1C,KAAK4C,aAAawH,QAAQF,GAC1BlK,KAAK4C,aAAayH,SAwCpBxH,EAAYzD,UAAUkL,oBAAsB,WAC1C,IAAIlI,EAAkBpC,KAAKoD,SAASF,qBAGpChD,OAAOC,KAAKyB,MAAM2I,QAAQnI,EAAiB,eAAgBpC,KAAKoD,UAE5DhB,EAAgBwC,iBAElB5E,KAAKK,KAAKqE,UAAU1E,KAAKoD,SAASsG,cAStC7G,EAAYzD,UAAUuE,MAAQ,WAE5B,GADA3D,KAAKqD,KAAOmH,SAASC,cAAc,OAC/BzK,KAAKuD,SAAU,CACjB,IAAImH,EAAM1K,KAAK2K,kBAAkB3K,KAAK0C,SACtC1C,KAAKqD,KAAKuH,MAAMC,QAAU7K,KAAK8K,UAAUJ,GACzC1K,KAAKqD,KAAK0H,UAAY/K,KAAKsD,MAAMiC,KACjC,IAAInD,EAAkBpC,KAAKoD,SAASF,qBAChCd,EAAgB1B,YAClBV,KAAKqD,KAAK2H,UAAY5I,EAAgB1B,WAI9BV,KAAKiL,WACXC,mBAAmBC,YAAYnL,KAAKqD,MAE1C,IAAI1B,EAAO3B,KACXE,OAAOC,KAAKyB,MAAMwJ,eAAepL,KAAKqD,KAAM,SAAS,WACnD1B,EAAK2I,0BAYTzH,EAAYzD,UAAUuL,kBAAoB,SAASU,GACjD,IAAIX,EAAM1K,KAAK+G,gBAAgBS,qBAAqB6D,GAGpD,OAFAX,EAAIjD,GAAKnC,SAAStF,KAAKsL,OAAS,EAAG,IACnCZ,EAAIhD,GAAKpC,SAAStF,KAAKuL,QAAU,EAAG,IAC7Bb,GAQT7H,EAAYzD,UAAUyE,KAAO,WAC3B,GAAI7D,KAAKuD,SAAU,CACjB,IAAImH,EAAM1K,KAAK2K,kBAAkB3K,KAAK0C,SACtC1C,KAAKqD,KAAKuH,MAAMY,IAAMd,EAAIhD,EAAI,KAC9B1H,KAAKqD,KAAKuH,MAAMa,KAAOf,EAAIjD,EAAI,OAQnC5E,EAAYzD,UAAU6K,KAAO,WACvBjK,KAAKqD,OACPrD,KAAKqD,KAAKuH,MAAMc,QAAU,QAE5B1L,KAAKuD,UAAW,GAOlBV,EAAYzD,UAAUiL,KAAO,WAC3B,GAAIrK,KAAKqD,KAAM,CACb,IAAIqH,EAAM1K,KAAK2K,kBAAkB3K,KAAK0C,SACtC1C,KAAKqD,KAAKuH,MAAMC,QAAU7K,KAAK8K,UAAUJ,GACzC1K,KAAKqD,KAAKuH,MAAMc,QAAU,GAE5B1L,KAAKuD,UAAW,GAOlBV,EAAYzD,UAAU+I,OAAS,WAC7BnI,KAAKwB,OAAO,OAQdqB,EAAYzD,UAAUuM,SAAW,WAC3B3L,KAAKqD,MAAQrD,KAAKqD,KAAKuI,aACzB5L,KAAKiK,OACLjK,KAAKqD,KAAKuI,WAAWC,YAAY7L,KAAKqD,MACtCrD,KAAKqD,KAAO,OAYhBR,EAAYzD,UAAUgL,QAAU,SAASF,GACvClK,KAAKsD,MAAQ4G,EACblK,KAAK8L,MAAQ5B,EAAK3E,KAClBvF,KAAK+L,OAAS7B,EAAK/E,MACfnF,KAAKqD,OACPrD,KAAKqD,KAAK0H,UAAYb,EAAK3E,MAG7BvF,KAAKgM,YAOPnJ,EAAYzD,UAAU4M,SAAW,WAC/B,IAAI7G,EAAQK,KAAKyG,IAAI,EAAGjM,KAAKsD,MAAM6B,MAAQ,GAC3CA,EAAQK,KAAKC,IAAIzF,KAAKS,QAAQwB,OAAS,EAAGkD,GAC1C,IAAIyF,EAAQ5K,KAAKS,QAAQ0E,GACzBnF,KAAKkM,KAAOtB,EAAK,IACjB5K,KAAKuL,QAAUX,EAAK,OACpB5K,KAAKsL,OAASV,EAAK,MACnB5K,KAAKmM,WAAavB,EAAK,UACvB5K,KAAKoM,QAAUxB,EAAK,OACpB5K,KAAKqM,UAAYzB,EAAK,SACtB5K,KAAKsM,oBAAsB1B,EAAK,oBASlC/H,EAAYzD,UAAU+K,UAAY,SAASb,GACzCtJ,KAAK0C,QAAU4G,GAUjBzG,EAAYzD,UAAU0L,UAAY,SAASJ,GACzC,IAAIE,EAAQ,GAEZ,GADsB5K,KAAKoD,SAASF,qBACfxC,UAgCnBkK,EAAM7G,KAAK,OAAS2G,EAAIhD,EAAI,YACxBgD,EAAIjD,EAAI,WAjCkB,CAC9BmD,EAAM7G,KAAK,wBAA0B/D,KAAKkM,KAAO,MACjD,IAAIK,EAAqBvM,KAAKsM,oBAAsBtM,KAAKsM,oBAAsB,MAC/E1B,EAAM7G,KAAK,uBAAyBwI,EAAqB,KAE7B,WAAxB,IAAOvM,KAAKoM,UACiB,iBAApBpM,KAAKoM,QAAQ,IAAmBpM,KAAKoM,QAAQ,GAAK,GACzDpM,KAAKoM,QAAQ,GAAKpM,KAAKuL,QACzBX,EAAM7G,KAAK,WAAa/D,KAAKuL,QAAUvL,KAAKoM,QAAQ,IAChD,mBAAqBpM,KAAKoM,QAAQ,GAAK,OAE3CxB,EAAM7G,KAAK,UAAY/D,KAAKuL,QAAU,mBAAqBvL,KAAKuL,QAAU,OAE7C,iBAApBvL,KAAKoM,QAAQ,IAAmBpM,KAAKoM,QAAQ,GAAK,GACzDpM,KAAKoM,QAAQ,GAAKpM,KAAKsL,OACzBV,EAAM7G,KAAK,UAAY/D,KAAKsL,OAAStL,KAAKoM,QAAQ,IAC9C,oBAAsBpM,KAAKoM,QAAQ,GAAK,OAE5CxB,EAAM7G,KAAK,SAAW/D,KAAKsL,OAAS,2BAGtCV,EAAM7G,KAAK,UAAY/D,KAAKuL,QAAU,mBAClCvL,KAAKuL,QAAU,aAAevL,KAAKsL,OAAS,0BAGlD,IAAIkB,EAAWxM,KAAKmM,WAAanM,KAAKmM,WAAa,QAC/CM,EAAUzM,KAAKqM,UAAYrM,KAAKqM,UAAY,GAEhDzB,EAAM7G,KAAK,yBAA2ByI,EAAW,kCAC7CC,EAAU,sDAMhB,OAAO7B,EAAM8B,KAAK,KAOpBpE,OAAM,gBAAsB1I,EAC5BA,EAAgBR,UAAhB,UAAyCQ,EAAgBR,UAAU6G,UACnErG,EAAgBR,UAAhB,WAA0CQ,EAAgBR,UAAU8C,WACpEtC,EAAgBR,UAAhB,aACIQ,EAAgBR,UAAU6I,aAC9BrI,EAAgBR,UAAhB,gBACIQ,EAAgBR,UAAU+E,gBAC9BvE,EAAgBR,UAAhB,cACIQ,EAAgBR,UAAUwG,cAC9BhG,EAAgBR,UAAhB,YACIQ,EAAgBR,UAAUmD,YAC9B3C,EAAgBR,UAAhB,kBACIQ,EAAgBR,UAAUyH,kBAC9BjH,EAAgBR,UAAhB,OAAsCQ,EAAgBR,UAAUkD,OAChE1C,EAAgBR,UAAhB,WAA0CQ,EAAgBR,UAAUkF,WACpE1E,EAAgBR,UAAhB,WAA0CQ,EAAgBR,UAAU4F,WACpEpF,EAAgBR,UAAhB,UAAyCQ,EAAgBR,UAAU0D,UACnElD,EAAgBR,UAAhB,iBACIQ,EAAgBR,UAAUsH,iBAC9B9G,EAAgBR,UAAhB,gBACIQ,EAAgBR,UAAUyF,gBAC9BjF,EAAgBR,UAAhB,OAAsCQ,EAAgBR,UAAU4C,OAChEpC,EAAgBR,UAAhB,aACIQ,EAAgBR,UAAUiH,aAC9BzG,EAAgBR,UAAhB,cACIQ,EAAgBR,UAAUmH,cAC9B3G,EAAgBR,UAAhB,cACIQ,EAAgBR,UAAU2C,cAC9BnC,EAAgBR,UAAhB,QACIQ,EAAgBR,UAAU4G,QAC9BpG,EAAgBR,UAAhB,cACIQ,EAAgBR,UAAUsG,cAC9B9F,EAAgBR,UAAhB,YACIQ,EAAgBR,UAAUuH,YAC9B/G,EAAgBR,UAAhB,WACIQ,EAAgBR,UAAU0F,WAC9BlF,EAAgBR,UAAhB,MAAqCQ,EAAgBR,UAAUuE,MAC/D/D,EAAgBR,UAAhB,KAAoCQ,EAAgBR,UAAUyE,KAE9D1B,EAAQ/C,UAAR,UAAiC+C,EAAQ/C,UAAUmK,UACnDpH,EAAQ/C,UAAR,QAA+B+C,EAAQ/C,UAAU2K,QACjD5H,EAAQ/C,UAAR,WAAkC+C,EAAQ/C,UAAUkF,WAEpDzB,EAAYzD,UAAZ,MAAiCyD,EAAYzD,UAAUuE,MACvDd,EAAYzD,UAAZ,KAAgCyD,EAAYzD,UAAUyE,KACtDhB,EAAYzD,UAAZ,SAAoCyD,EAAYzD,UAAUuM","file":"markerclusterer.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 52);\n","function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","// ==ClosureCompiler==\r\n// @compilation_level ADVANCED_OPTIMIZATIONS\r\n// @externs_url http://closure-compiler.googlecode.com/svn/trunk/contrib/externs/maps/google_maps_api_v3_3.js\r\n// ==/ClosureCompiler==\r\n\r\n/**\r\n * @name MarkerClusterer for Google Maps v3\r\n * @version version 1.0\r\n * @author Luke Mahe\r\n * @fileoverview\r\n * The library creates and manages per-zoom-level clusters for large amounts of\r\n * markers.\r\n * <br/>\r\n * This is a v3 implementation of the\r\n * <a href=\"http://gmaps-utility-library-dev.googlecode.com/svn/tags/markerclusterer/\"\r\n * >v2 MarkerClusterer</a>.\r\n */\r\n\r\n/**\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n\r\n/**\r\n * A Marker Clusterer that clusters markers.\r\n *\r\n * @param {google.maps.Map} map The Google map to attach to.\r\n * @param {Array.<google.maps.Marker>=} opt_markers Optional markers to add to\r\n *   the cluster.\r\n * @param {Object=} opt_options support the following options:\r\n *     'gridSize': (number) The grid size of a cluster in pixels.\r\n *     'maxZoom': (number) The maximum zoom level that a marker can be part of a\r\n *                cluster.\r\n *     'zoomOnClick': (boolean) Whether the default behaviour of clicking on a\r\n *                    cluster is to zoom into it.\r\n *     'averageCenter': (boolean) Wether the center of each cluster should be\r\n *                      the average of all markers in the cluster.\r\n *     'minimumClusterSize': (number) The minimum number of markers to be in a\r\n *                           cluster before the markers are hidden and a count\r\n *                           is shown.\r\n *     'styles': (object) An object that has style properties:\r\n *       'url': (string) The image url.\r\n *       'height': (number) The image height.\r\n *       'width': (number) The image width.\r\n *       'anchor': (Array) The anchor position of the label text.\r\n *       'textColor': (string) The text color.\r\n *       'textSize': (number) The text size.\r\n *       'backgroundPosition': (string) The position of the background x, y.\r\n *     'cssClass': (string) One or more CSS class for styling this marker.\r\n * @constructor\r\n * @extends google.maps.OverlayView\r\n */\r\nfunction MarkerClusterer(map, opt_markers, opt_options) {\r\n    // MarkerClusterer implements google.maps.OverlayView interface. We use the\r\n    // extend function to extend MarkerClusterer with google.maps.OverlayView\r\n    // because it might not always be available when the code is defined so we\r\n    // look for it at the last possible moment. If it doesn't exist now then\r\n    // there is no point going ahead :)\r\n    this.extend(MarkerClusterer, google.maps.OverlayView);\r\n    this.map_ = map;\r\n\r\n    /**\r\n     * @type {Array.<google.maps.Marker>}\r\n     * @private\r\n     */\r\n    this.markers_ = [];\r\n\r\n    /**\r\n     *  @type {Array.<Cluster>}\r\n     */\r\n    this.clusters_ = [];\r\n\r\n    this.sizes = [53, 56, 66, 78, 90];\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.styles_ = [];\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.cssClass_ = '';\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.ready_ = false;\r\n\r\n    var options = opt_options || {};\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.gridSize_ = options['gridSize'] || 60;\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.minClusterSize_ = options['minimumClusterSize'] || 2;\r\n\r\n\r\n    /**\r\n     * @type {?number}\r\n     * @private\r\n     */\r\n    this.maxZoom_ = options['maxZoom'] || null;\r\n\r\n    this.styles_ = options['styles'] || [];\r\n\r\n    this.cssClass_ = options['cssClass'] || null;\r\n\r\n    /**\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    this.imagePath_ = options['imagePath'] ||\r\n        this.MARKER_CLUSTER_IMAGE_PATH_;\r\n\r\n    /**\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    this.imageExtension_ = options['imageExtension'] ||\r\n        this.MARKER_CLUSTER_IMAGE_EXTENSION_;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.zoomOnClick_ = true;\r\n\r\n    if (options['zoomOnClick'] != undefined) {\r\n      this.zoomOnClick_ = options['zoomOnClick'];\r\n    }\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.averageCenter_ = false;\r\n\r\n    if (options['averageCenter'] != undefined) {\r\n      this.averageCenter_ = options['averageCenter'];\r\n    }\r\n\r\n    this.setupStyles_();\r\n\r\n    this.setMap(map);\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.prevZoom_ = this.map_.getZoom();\r\n\r\n    // Add the map event listeners\r\n    var that = this;\r\n    google.maps.event.addListener(this.map_, 'zoom_changed', function() {\r\n      var zoom = that.map_.getZoom();\r\n\r\n      if (that.prevZoom_ != zoom) {\r\n        that.prevZoom_ = zoom;\r\n        that.resetViewport();\r\n      }\r\n    });\r\n\r\n    google.maps.event.addListener(this.map_, 'idle', function() {\r\n      that.redraw();\r\n    });\r\n\r\n    // Finally, add the markers\r\n    if (opt_markers && opt_markers.length) {\r\n      this.addMarkers(opt_markers, false);\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * The marker cluster image path.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   */\r\n  MarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_PATH_ =\r\n      'http://google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclusterer/' +\r\n      'images/m';\r\n\r\n\r\n  /**\r\n   * The marker cluster image path.\r\n   *\r\n   * @type {string}\r\n   * @private\r\n   */\r\n  MarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_EXTENSION_ = 'png';\r\n\r\n\r\n  /**\r\n   * Extends a objects prototype by anothers.\r\n   *\r\n   * @param {Object} obj1 The object to be extended.\r\n   * @param {Object} obj2 The object to extend with.\r\n   * @return {Object} The new extended object.\r\n   * @ignore\r\n   */\r\n  MarkerClusterer.prototype.extend = function(obj1, obj2) {\r\n    return (function(object) {\r\n      for (var property in object.prototype) {\r\n        this.prototype[property] = object.prototype[property];\r\n      }\r\n      return this;\r\n    }).apply(obj1, [obj2]);\r\n  };\r\n\r\n\r\n  /**\r\n   * Implementaion of the interface method.\r\n   * @ignore\r\n   */\r\n  MarkerClusterer.prototype.onAdd = function() {\r\n    this.setReady_(true);\r\n  };\r\n\r\n  /**\r\n   * Implementaion of the interface method.\r\n   * @ignore\r\n   */\r\n  MarkerClusterer.prototype.draw = function() {};\r\n\r\n  /**\r\n   * Sets up the styles object.\r\n   *\r\n   * @private\r\n   */\r\n  MarkerClusterer.prototype.setupStyles_ = function() {\r\n    if (this.styles_.length) {\r\n      return;\r\n    }\r\n\r\n    for (var i = 0, size; size = this.sizes[i]; i++) {\r\n      this.styles_.push({\r\n        url: this.imagePath_ + (i + 1) + '.' + this.imageExtension_,\r\n        height: size,\r\n        width: size\r\n      });\r\n    }\r\n  };\r\n\r\n  /**\r\n   *  Fit the map to the bounds of the markers in the clusterer.\r\n   */\r\n  MarkerClusterer.prototype.fitMapToMarkers = function() {\r\n    var markers = this.getMarkers();\r\n    var bounds = new google.maps.LatLngBounds();\r\n    for (var i = 0, marker; marker = markers[i]; i++) {\r\n      bounds.extend(marker.getPosition());\r\n    }\r\n\r\n    this.map_.fitBounds(bounds);\r\n  };\r\n\r\n\r\n  /**\r\n   *  Sets the styles.\r\n   *\r\n   *  @param {Object} styles The style to set.\r\n   */\r\n  MarkerClusterer.prototype.setStyles = function(styles) {\r\n    this.styles_ = styles;\r\n  };\r\n\r\n\r\n  /**\r\n   *  Gets the styles.\r\n   *\r\n   *  @return {Object} The styles object.\r\n   */\r\n  MarkerClusterer.prototype.getStyles = function() {\r\n    return this.styles_;\r\n  };\r\n\r\n\r\n  /**\r\n   * Whether zoom on click is set.\r\n   *\r\n   * @return {boolean} True if zoomOnClick_ is set.\r\n   */\r\n  MarkerClusterer.prototype.isZoomOnClick = function() {\r\n    return this.zoomOnClick_;\r\n  };\r\n\r\n  /**\r\n   * Whether average center is set.\r\n   *\r\n   * @return {boolean} True if averageCenter_ is set.\r\n   */\r\n  MarkerClusterer.prototype.isAverageCenter = function() {\r\n    return this.averageCenter_;\r\n  };\r\n\r\n\r\n  /**\r\n   *  Returns the array of markers in the clusterer.\r\n   *\r\n   *  @return {Array.<google.maps.Marker>} The markers.\r\n   */\r\n  MarkerClusterer.prototype.getMarkers = function() {\r\n    return this.markers_;\r\n  };\r\n\r\n\r\n  /**\r\n   *  Returns the number of markers in the clusterer\r\n   *\r\n   *  @return {Number} The number of markers.\r\n   */\r\n  MarkerClusterer.prototype.getTotalMarkers = function() {\r\n    return this.markers_.length;\r\n  };\r\n\r\n\r\n  /**\r\n   *  Sets the max zoom for the clusterer.\r\n   *\r\n   *  @param {number} maxZoom The max zoom level.\r\n   */\r\n  MarkerClusterer.prototype.setMaxZoom = function(maxZoom) {\r\n    this.maxZoom_ = maxZoom;\r\n  };\r\n\r\n\r\n  /**\r\n   *  Gets the max zoom for the clusterer.\r\n   *\r\n   *  @return {number} The max zoom level.\r\n   */\r\n  MarkerClusterer.prototype.getMaxZoom = function() {\r\n    return this.maxZoom_;\r\n  };\r\n\r\n\r\n  /**\r\n   *  The function for calculating the cluster icon image.\r\n   *\r\n   *  @param {Array.<google.maps.Marker>} markers The markers in the clusterer.\r\n   *  @param {number} numStyles The number of styles available.\r\n   *  @return {Object} A object properties: 'text' (string) and 'index' (number).\r\n   *  @private\r\n   */\r\n  MarkerClusterer.prototype.calculator_ = function(markers, numStyles) {\r\n    var index = 0;\r\n    var count = markers.length;\r\n    var dv = count;\r\n    while (dv !== 0) {\r\n      dv = parseInt(dv / 10, 10);\r\n      index++;\r\n    }\r\n\r\n    index = Math.min(index, numStyles);\r\n    return {\r\n      text: count,\r\n      index: index\r\n    };\r\n  };\r\n\r\n\r\n  /**\r\n   * Set the calculator function.\r\n   *\r\n   * @param {function(Array, number)} calculator The function to set as the\r\n   *     calculator. The function should return a object properties:\r\n   *     'text' (string) and 'index' (number).\r\n   *\r\n   */\r\n  MarkerClusterer.prototype.setCalculator = function(calculator) {\r\n    this.calculator_ = calculator;\r\n  };\r\n\r\n\r\n  /**\r\n   * Get the calculator function.\r\n   *\r\n   * @return {function(Array, number)} the calculator function.\r\n   */\r\n  MarkerClusterer.prototype.getCalculator = function() {\r\n    return this.calculator_;\r\n  };\r\n\r\n\r\n  /**\r\n   * Add an array of markers to the clusterer.\r\n   *\r\n   * @param {Array.<google.maps.Marker>} markers The markers to add.\r\n   * @param {boolean=} opt_nodraw Whether to redraw the clusters.\r\n   */\r\n  MarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {\r\n    for (var i = 0, marker; marker = markers[i]; i++) {\r\n      this.pushMarkerTo_(marker);\r\n    }\r\n    if (!opt_nodraw) {\r\n      this.redraw();\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Pushes a marker to the clusterer.\r\n   *\r\n   * @param {google.maps.Marker} marker The marker to add.\r\n   * @private\r\n   */\r\n  MarkerClusterer.prototype.pushMarkerTo_ = function(marker) {\r\n    marker.isAdded = false;\r\n    if (marker['draggable']) {\r\n      // If the marker is draggable add a listener so we update the clusters on\r\n      // the drag end.\r\n      var that = this;\r\n      google.maps.event.addListener(marker, 'dragend', function() {\r\n        marker.isAdded = false;\r\n        that.repaint();\r\n      });\r\n    }\r\n    this.markers_.push(marker);\r\n  };\r\n\r\n\r\n  /**\r\n   * Adds a marker to the clusterer and redraws if needed.\r\n   *\r\n   * @param {google.maps.Marker} marker The marker to add.\r\n   * @param {boolean=} opt_nodraw Whether to redraw the clusters.\r\n   */\r\n  MarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {\r\n    this.pushMarkerTo_(marker);\r\n    if (!opt_nodraw) {\r\n      this.redraw();\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Removes a marker and returns true if removed, false if not\r\n   *\r\n   * @param {google.maps.Marker} marker The marker to remove\r\n   * @return {boolean} Whether the marker was removed or not\r\n   * @private\r\n   */\r\n  MarkerClusterer.prototype.removeMarker_ = function(marker) {\r\n    var index = -1;\r\n    if (this.markers_.indexOf) {\r\n      index = this.markers_.indexOf(marker);\r\n    } else {\r\n      for (var i = 0, m; m = this.markers_[i]; i++) {\r\n        if (m == marker) {\r\n          index = i;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (index == -1) {\r\n      // Marker is not in our list of markers.\r\n      return false;\r\n    }\r\n\r\n    marker.setMap(null);\r\n\r\n    this.markers_.splice(index, 1);\r\n\r\n    return true;\r\n  };\r\n\r\n\r\n  /**\r\n   * Remove a marker from the cluster.\r\n   *\r\n   * @param {google.maps.Marker} marker The marker to remove.\r\n   * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\r\n   * @return {boolean} True if the marker was removed.\r\n   */\r\n  MarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw) {\r\n    var removed = this.removeMarker_(marker);\r\n\r\n    if (!opt_nodraw && removed) {\r\n      this.resetViewport();\r\n      this.redraw();\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Removes an array of markers from the cluster.\r\n   *\r\n   * @param {Array.<google.maps.Marker>} markers The markers to remove.\r\n   * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\r\n   */\r\n  MarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw) {\r\n    var removed = false;\r\n\r\n    for (var i = 0, marker; marker = markers[i]; i++) {\r\n      var r = this.removeMarker_(marker);\r\n      removed = removed || r;\r\n    }\r\n\r\n    if (!opt_nodraw && removed) {\r\n      this.resetViewport();\r\n      this.redraw();\r\n      return true;\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Sets the clusterer's ready state.\r\n   *\r\n   * @param {boolean} ready The state.\r\n   * @private\r\n   */\r\n  MarkerClusterer.prototype.setReady_ = function(ready) {\r\n    if (!this.ready_) {\r\n      this.ready_ = ready;\r\n      this.createClusters_();\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Returns the number of clusters in the clusterer.\r\n   *\r\n   * @return {number} The number of clusters.\r\n   */\r\n  MarkerClusterer.prototype.getTotalClusters = function() {\r\n    return this.clusters_.length;\r\n  };\r\n\r\n\r\n  /**\r\n   * Returns the google map that the clusterer is associated with.\r\n   *\r\n   * @return {google.maps.Map} The map.\r\n   */\r\n  MarkerClusterer.prototype.getMap = function() {\r\n    return this.map_;\r\n  };\r\n\r\n\r\n  /**\r\n   * Sets the google map that the clusterer is associated with.\r\n   *\r\n   * @param {google.maps.Map} map The map.\r\n   */\r\n  MarkerClusterer.prototype.setMap = function(map) {\r\n    this.map_ = map;\r\n  };\r\n\r\n\r\n  /**\r\n   * Returns the size of the grid.\r\n   *\r\n   * @return {number} The grid size.\r\n   */\r\n  MarkerClusterer.prototype.getGridSize = function() {\r\n    return this.gridSize_;\r\n  };\r\n\r\n\r\n  /**\r\n   * Sets the size of the grid.\r\n   *\r\n   * @param {number} size The grid size.\r\n   */\r\n  MarkerClusterer.prototype.setGridSize = function(size) {\r\n    this.gridSize_ = size;\r\n  };\r\n\r\n\r\n  /**\r\n   * Returns the min cluster size.\r\n   *\r\n   * @return {number} The grid size.\r\n   */\r\n  MarkerClusterer.prototype.getMinClusterSize = function() {\r\n    return this.minClusterSize_;\r\n  };\r\n\r\n  /**\r\n   * Sets the min cluster size.\r\n   *\r\n   * @param {number} size The grid size.\r\n   */\r\n  MarkerClusterer.prototype.setMinClusterSize = function(size) {\r\n    this.minClusterSize_ = size;\r\n  };\r\n\r\n\r\n  /**\r\n   * Extends a bounds object by the grid size.\r\n   *\r\n   * @param {google.maps.LatLngBounds} bounds The bounds to extend.\r\n   * @return {google.maps.LatLngBounds} The extended bounds.\r\n   */\r\n  MarkerClusterer.prototype.getExtendedBounds = function(bounds) {\r\n    var projection = this.getProjection();\r\n\r\n    // Turn the bounds into latlng.\r\n    var tr = new google.maps.LatLng(bounds.getNorthEast().lat(),\r\n        bounds.getNorthEast().lng());\r\n    var bl = new google.maps.LatLng(bounds.getSouthWest().lat(),\r\n        bounds.getSouthWest().lng());\r\n\r\n    // Convert the points to pixels and the extend out by the grid size.\r\n    var trPix = projection.fromLatLngToDivPixel(tr);\r\n    trPix.x += this.gridSize_;\r\n    trPix.y -= this.gridSize_;\r\n\r\n    var blPix = projection.fromLatLngToDivPixel(bl);\r\n    blPix.x -= this.gridSize_;\r\n    blPix.y += this.gridSize_;\r\n\r\n    // Convert the pixel points back to LatLng\r\n    var ne = projection.fromDivPixelToLatLng(trPix);\r\n    var sw = projection.fromDivPixelToLatLng(blPix);\r\n\r\n    // Extend the bounds to contain the new bounds.\r\n    bounds.extend(ne);\r\n    bounds.extend(sw);\r\n\r\n    return bounds;\r\n  };\r\n\r\n\r\n  /**\r\n   * Determins if a marker is contained in a bounds.\r\n   *\r\n   * @param {google.maps.Marker} marker The marker to check.\r\n   * @param {google.maps.LatLngBounds} bounds The bounds to check against.\r\n   * @return {boolean} True if the marker is in the bounds.\r\n   * @private\r\n   */\r\n  MarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {\r\n    return bounds.contains(marker.getPosition());\r\n  };\r\n\r\n\r\n  /**\r\n   * Clears all clusters and markers from the clusterer.\r\n   */\r\n  MarkerClusterer.prototype.clearMarkers = function() {\r\n    this.resetViewport(true);\r\n\r\n    // Set the markers a empty array.\r\n    this.markers_ = [];\r\n  };\r\n\r\n\r\n  /**\r\n   * Clears all existing clusters and recreates them.\r\n   * @param {boolean} opt_hide To also hide the marker.\r\n   */\r\n  MarkerClusterer.prototype.resetViewport = function(opt_hide) {\r\n    // Remove all the clusters\r\n    for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\r\n      cluster.remove();\r\n    }\r\n\r\n    // Reset the markers to not be added and to be invisible.\r\n    for (var i = 0, marker; marker = this.markers_[i]; i++) {\r\n      marker.isAdded = false;\r\n      if (opt_hide) {\r\n        marker.setMap(null);\r\n      }\r\n    }\r\n\r\n    this.clusters_ = [];\r\n  };\r\n\r\n  /**\r\n   *\r\n   */\r\n  MarkerClusterer.prototype.repaint = function() {\r\n    var oldClusters = this.clusters_.slice();\r\n    this.clusters_.length = 0;\r\n    this.resetViewport();\r\n    this.redraw();\r\n\r\n    // Remove the old clusters.\r\n    // Do it in a timeout so the other clusters have been drawn first.\r\n    window.setTimeout(function() {\r\n      for (var i = 0, cluster; cluster = oldClusters[i]; i++) {\r\n        cluster.remove();\r\n      }\r\n    }, 0);\r\n  };\r\n\r\n\r\n  /**\r\n   * Redraws the clusters.\r\n   */\r\n  MarkerClusterer.prototype.redraw = function() {\r\n    this.createClusters_();\r\n  };\r\n\r\n\r\n  /**\r\n   * Calculates the distance between two latlng locations in km.\r\n   * @see http://www.movable-type.co.uk/scripts/latlong.html\r\n   *\r\n   * @param {google.maps.LatLng} p1 The first lat lng point.\r\n   * @param {google.maps.LatLng} p2 The second lat lng point.\r\n   * @return {number} The distance between the two points in km.\r\n   * @private\r\n   */\r\n  MarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {\r\n    if (!p1 || !p2) {\r\n      return 0;\r\n    }\r\n\r\n    var R = 6371; // Radius of the Earth in km\r\n    var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;\r\n    var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;\r\n    var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\r\n        Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *\r\n        Math.sin(dLon / 2) * Math.sin(dLon / 2);\r\n    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n    var d = R * c;\r\n    return d;\r\n  };\r\n\r\n\r\n  /**\r\n   * Add a marker to a cluster, or creates a new cluster.\r\n   *\r\n   * @param {google.maps.Marker} marker The marker to add.\r\n   * @private\r\n   */\r\n  MarkerClusterer.prototype.addToClosestCluster_ = function(marker) {\r\n    var distance = 40000; // Some large number\r\n    var clusterToAddTo = null;\r\n    var pos = marker.getPosition();\r\n    for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\r\n      var center = cluster.getCenter();\r\n      if (center) {\r\n        var d = this.distanceBetweenPoints_(center, marker.getPosition());\r\n        if (d < distance) {\r\n          distance = d;\r\n          clusterToAddTo = cluster;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {\r\n      clusterToAddTo.addMarker(marker);\r\n    } else {\r\n      var cluster = new Cluster(this);\r\n      cluster.addMarker(marker);\r\n      this.clusters_.push(cluster);\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Creates the clusters.\r\n   *\r\n   * @private\r\n   */\r\n  MarkerClusterer.prototype.createClusters_ = function() {\r\n    if (!this.ready_) {\r\n      return;\r\n    }\r\n\r\n    // Get our current map view bounds.\r\n    // Create a new bounds object so we don't affect the map.\r\n    var mapBounds = new google.maps.LatLngBounds(this.map_.getBounds().getSouthWest(),\r\n        this.map_.getBounds().getNorthEast());\r\n    var bounds = this.getExtendedBounds(mapBounds);\r\n\r\n    for (var i = 0, marker; marker = this.markers_[i]; i++) {\r\n      if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {\r\n        this.addToClosestCluster_(marker);\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * A cluster that contains markers.\r\n   *\r\n   * @param {MarkerClusterer} markerClusterer The markerclusterer that this\r\n   *     cluster is associated with.\r\n   * @constructor\r\n   * @ignore\r\n   */\r\n  function Cluster(markerClusterer) {\r\n    this.markerClusterer_ = markerClusterer;\r\n    this.map_ = markerClusterer.getMap();\r\n    this.gridSize_ = markerClusterer.getGridSize();\r\n    this.minClusterSize_ = markerClusterer.getMinClusterSize();\r\n    this.averageCenter_ = markerClusterer.isAverageCenter();\r\n    this.center_ = null;\r\n    this.markers_ = [];\r\n    this.bounds_ = null;\r\n    this.clusterIcon_ = new ClusterIcon(this, markerClusterer.getStyles(),\r\n        markerClusterer.getGridSize());\r\n  }\r\n\r\n  /**\r\n   * Determins if a marker is already added to the cluster.\r\n   *\r\n   * @param {google.maps.Marker} marker The marker to check.\r\n   * @return {boolean} True if the marker is already added.\r\n   */\r\n  Cluster.prototype.isMarkerAlreadyAdded = function(marker) {\r\n    if (this.markers_.indexOf) {\r\n      return this.markers_.indexOf(marker) != -1;\r\n    } else {\r\n      for (var i = 0, m; m = this.markers_[i]; i++) {\r\n        if (m == marker) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  };\r\n\r\n\r\n  /**\r\n   * Add a marker the cluster.\r\n   *\r\n   * @param {google.maps.Marker} marker The marker to add.\r\n   * @return {boolean} True if the marker was added.\r\n   */\r\n  Cluster.prototype.addMarker = function(marker) {\r\n    if (this.isMarkerAlreadyAdded(marker)) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.center_) {\r\n      this.center_ = marker.getPosition();\r\n      this.calculateBounds_();\r\n    } else {\r\n      if (this.averageCenter_) {\r\n        var l = this.markers_.length + 1;\r\n        var lat = (this.center_.lat() * (l-1) + marker.getPosition().lat()) / l;\r\n        var lng = (this.center_.lng() * (l-1) + marker.getPosition().lng()) / l;\r\n        this.center_ = new google.maps.LatLng(lat, lng);\r\n        this.calculateBounds_();\r\n      }\r\n    }\r\n\r\n    marker.isAdded = true;\r\n    this.markers_.push(marker);\r\n\r\n    var len = this.markers_.length;\r\n    if (len < this.minClusterSize_ && marker.getMap() != this.map_) {\r\n      // Min cluster size not reached so show the marker.\r\n      marker.setMap(this.map_);\r\n    }\r\n\r\n    if (len == this.minClusterSize_) {\r\n      // Hide the markers that were showing.\r\n      for (var i = 0; i < len; i++) {\r\n        this.markers_[i].setMap(null);\r\n      }\r\n    }\r\n\r\n    if (len >= this.minClusterSize_) {\r\n      marker.setMap(null);\r\n    }\r\n\r\n    this.updateIcon();\r\n    return true;\r\n  };\r\n\r\n\r\n  /**\r\n   * Returns the marker clusterer that the cluster is associated with.\r\n   *\r\n   * @return {MarkerClusterer} The associated marker clusterer.\r\n   */\r\n  Cluster.prototype.getMarkerClusterer = function() {\r\n    return this.markerClusterer_;\r\n  };\r\n\r\n\r\n  /**\r\n   * Returns the bounds of the cluster.\r\n   *\r\n   * @return {google.maps.LatLngBounds} the cluster bounds.\r\n   */\r\n  Cluster.prototype.getBounds = function() {\r\n    var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\r\n    var markers = this.getMarkers();\r\n    for (var i = 0, marker; marker = markers[i]; i++) {\r\n      bounds.extend(marker.getPosition());\r\n    }\r\n    return bounds;\r\n  };\r\n\r\n\r\n  /**\r\n   * Removes the cluster\r\n   */\r\n  Cluster.prototype.remove = function() {\r\n    this.clusterIcon_.remove();\r\n    this.markers_.length = 0;\r\n    delete this.markers_;\r\n  };\r\n\r\n\r\n  /**\r\n   * Returns the center of the cluster.\r\n   *\r\n   * @return {number} The cluster center.\r\n   */\r\n  Cluster.prototype.getSize = function() {\r\n    return this.markers_.length;\r\n  };\r\n\r\n\r\n  /**\r\n   * Returns the center of the cluster.\r\n   *\r\n   * @return {Array.<google.maps.Marker>} The cluster center.\r\n   */\r\n  Cluster.prototype.getMarkers = function() {\r\n    return this.markers_;\r\n  };\r\n\r\n\r\n  /**\r\n   * Returns the center of the cluster.\r\n   *\r\n   * @return {google.maps.LatLng} The cluster center.\r\n   */\r\n  Cluster.prototype.getCenter = function() {\r\n    return this.center_;\r\n  };\r\n\r\n\r\n  /**\r\n   * Calculated the extended bounds of the cluster with the grid.\r\n   *\r\n   * @private\r\n   */\r\n  Cluster.prototype.calculateBounds_ = function() {\r\n    var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\r\n    this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);\r\n  };\r\n\r\n\r\n  /**\r\n   * Determines if a marker lies in the clusters bounds.\r\n   *\r\n   * @param {google.maps.Marker} marker The marker to check.\r\n   * @return {boolean} True if the marker lies in the bounds.\r\n   */\r\n  Cluster.prototype.isMarkerInClusterBounds = function(marker) {\r\n    return this.bounds_.contains(marker.getPosition());\r\n  };\r\n\r\n\r\n  /**\r\n   * Returns the map that the cluster is associated with.\r\n   *\r\n   * @return {google.maps.Map} The map.\r\n   */\r\n  Cluster.prototype.getMap = function() {\r\n    return this.map_;\r\n  };\r\n\r\n\r\n  /**\r\n   * Updates the cluster icon\r\n   */\r\n  Cluster.prototype.updateIcon = function() {\r\n    var zoom = this.map_.getZoom();\r\n    var mz = this.markerClusterer_.getMaxZoom();\r\n\r\n    if (mz && zoom > mz) {\r\n      // The zoom is greater than our max zoom so show all the markers in cluster.\r\n      for (var i = 0, marker; marker = this.markers_[i]; i++) {\r\n        marker.setMap(this.map_);\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (this.markers_.length < this.minClusterSize_) {\r\n      // Min cluster size not yet reached.\r\n      this.clusterIcon_.hide();\r\n      return;\r\n    }\r\n\r\n    var numStyles = this.markerClusterer_.getStyles().length;\r\n    var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);\r\n    this.clusterIcon_.setCenter(this.center_);\r\n    this.clusterIcon_.setSums(sums);\r\n    this.clusterIcon_.show();\r\n  };\r\n\r\n\r\n  /**\r\n   * A cluster icon\r\n   *\r\n   * @param {Cluster} cluster The cluster to be associated with.\r\n   * @param {Object} styles An object that has style properties:\r\n   *     'url': (string) The image url.\r\n   *     'height': (number) The image height.\r\n   *     'width': (number) The image width.\r\n   *     'anchor': (Array) The anchor position of the label text.\r\n   *     'textColor': (string) The text color.\r\n   *     'textSize': (number) The text size.\r\n   *     'backgroundPosition: (string) The background postition x, y.\r\n   * @param {number=} opt_padding Optional padding to apply to the cluster icon.\r\n   * @constructor\r\n   * @extends google.maps.OverlayView\r\n   * @ignore\r\n   */\r\n  function ClusterIcon(cluster, styles, opt_padding) {\r\n    cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);\r\n\r\n    this.styles_ = styles;\r\n    this.padding_ = opt_padding || 0;\r\n    this.cluster_ = cluster;\r\n    this.center_ = null;\r\n    this.map_ = cluster.getMap();\r\n    this.div_ = null;\r\n    this.sums_ = null;\r\n    this.visible_ = false;\r\n\r\n    this.setMap(this.map_);\r\n  }\r\n\r\n\r\n  /**\r\n   * Triggers the clusterclick event and zoom's if the option is set.\r\n   */\r\n  ClusterIcon.prototype.triggerClusterClick = function() {\r\n    var markerClusterer = this.cluster_.getMarkerClusterer();\r\n\r\n    // Trigger the clusterclick event.\r\n    google.maps.event.trigger(markerClusterer, 'clusterclick', this.cluster_);\r\n\r\n    if (markerClusterer.isZoomOnClick()) {\r\n      // Zoom into the cluster.\r\n      this.map_.fitBounds(this.cluster_.getBounds());\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Adding the cluster icon to the dom.\r\n   * @ignore\r\n   */\r\n  ClusterIcon.prototype.onAdd = function() {\r\n    this.div_ = document.createElement('DIV');\r\n    if (this.visible_) {\r\n      var pos = this.getPosFromLatLng_(this.center_);\r\n      this.div_.style.cssText = this.createCss(pos);\r\n      this.div_.innerHTML = this.sums_.text;\r\n      var markerClusterer = this.cluster_.getMarkerClusterer();\r\n      if (markerClusterer.cssClass_) {\r\n        this.div_.className = markerClusterer.cssClass_;\r\n      }\r\n    }\r\n\r\n    var panes = this.getPanes();\r\n    panes.overlayMouseTarget.appendChild(this.div_);\r\n\r\n    var that = this;\r\n    google.maps.event.addDomListener(this.div_, 'click', function() {\r\n      that.triggerClusterClick();\r\n    });\r\n  };\r\n\r\n\r\n  /**\r\n   * Returns the position to place the div dending on the latlng.\r\n   *\r\n   * @param {google.maps.LatLng} latlng The position in latlng.\r\n   * @return {google.maps.Point} The position in pixels.\r\n   * @private\r\n   */\r\n  ClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {\r\n    var pos = this.getProjection().fromLatLngToDivPixel(latlng);\r\n    pos.x -= parseInt(this.width_ / 2, 10);\r\n    pos.y -= parseInt(this.height_ / 2, 10);\r\n    return pos;\r\n  };\r\n\r\n\r\n  /**\r\n   * Draw the icon.\r\n   * @ignore\r\n   */\r\n  ClusterIcon.prototype.draw = function() {\r\n    if (this.visible_) {\r\n      var pos = this.getPosFromLatLng_(this.center_);\r\n      this.div_.style.top = pos.y + 'px';\r\n      this.div_.style.left = pos.x + 'px';\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Hide the icon.\r\n   */\r\n  ClusterIcon.prototype.hide = function() {\r\n    if (this.div_) {\r\n      this.div_.style.display = 'none';\r\n    }\r\n    this.visible_ = false;\r\n  };\r\n\r\n\r\n  /**\r\n   * Position and show the icon.\r\n   */\r\n  ClusterIcon.prototype.show = function() {\r\n    if (this.div_) {\r\n      var pos = this.getPosFromLatLng_(this.center_);\r\n      this.div_.style.cssText = this.createCss(pos);\r\n      this.div_.style.display = '';\r\n    }\r\n    this.visible_ = true;\r\n  };\r\n\r\n\r\n  /**\r\n   * Remove the icon from the map\r\n   */\r\n  ClusterIcon.prototype.remove = function() {\r\n    this.setMap(null);\r\n  };\r\n\r\n\r\n  /**\r\n   * Implementation of the onRemove interface.\r\n   * @ignore\r\n   */\r\n  ClusterIcon.prototype.onRemove = function() {\r\n    if (this.div_ && this.div_.parentNode) {\r\n      this.hide();\r\n      this.div_.parentNode.removeChild(this.div_);\r\n      this.div_ = null;\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Set the sums of the icon.\r\n   *\r\n   * @param {Object} sums The sums containing:\r\n   *   'text': (string) The text to display in the icon.\r\n   *   'index': (number) The style index of the icon.\r\n   */\r\n  ClusterIcon.prototype.setSums = function(sums) {\r\n    this.sums_ = sums;\r\n    this.text_ = sums.text;\r\n    this.index_ = sums.index;\r\n    if (this.div_) {\r\n      this.div_.innerHTML = sums.text;\r\n    }\r\n\r\n    this.useStyle();\r\n  };\r\n\r\n\r\n  /**\r\n   * Sets the icon to the the styles.\r\n   */\r\n  ClusterIcon.prototype.useStyle = function() {\r\n    var index = Math.max(0, this.sums_.index - 1);\r\n    index = Math.min(this.styles_.length - 1, index);\r\n    var style = this.styles_[index];\r\n    this.url_ = style['url'];\r\n    this.height_ = style['height'];\r\n    this.width_ = style['width'];\r\n    this.textColor_ = style['textColor'];\r\n    this.anchor_ = style['anchor'];\r\n    this.textSize_ = style['textSize'];\r\n    this.backgroundPosition_ = style['backgroundPosition'];\r\n  };\r\n\r\n\r\n  /**\r\n   * Sets the center of the icon.\r\n   *\r\n   * @param {google.maps.LatLng} center The latlng to set as the center.\r\n   */\r\n  ClusterIcon.prototype.setCenter = function(center) {\r\n    this.center_ = center;\r\n  };\r\n\r\n\r\n  /**\r\n   * Create the css text based on the position of the icon.\r\n   *\r\n   * @param {google.maps.Point} pos The position.\r\n   * @return {string} The css style text.\r\n   */\r\n  ClusterIcon.prototype.createCss = function(pos) {\r\n    var style = [];\r\n    var markerClusterer = this.cluster_.getMarkerClusterer();\r\n    if (!markerClusterer.cssClass_) {\r\n      style.push('background-image:url(' + this.url_ + ');');\r\n      var backgroundPosition = this.backgroundPosition_ ? this.backgroundPosition_ : '0 0';\r\n      style.push('background-position:' + backgroundPosition + ';');\r\n\r\n      if (typeof this.anchor_ === 'object') {\r\n        if (typeof this.anchor_[0] === 'number' && this.anchor_[0] > 0 &&\r\n            this.anchor_[0] < this.height_) {\r\n          style.push('height:' + (this.height_ - this.anchor_[0]) +\r\n              'px; padding-top:' + this.anchor_[0] + 'px;');\r\n        } else {\r\n          style.push('height:' + this.height_ + 'px; line-height:' + this.height_ + 'px;');\r\n        }\r\n        if (typeof this.anchor_[1] === 'number' && this.anchor_[1] > 0 &&\r\n            this.anchor_[1] < this.width_) {\r\n          style.push('width:' + (this.width_ - this.anchor_[1]) +\r\n              'px; padding-left:' + this.anchor_[1] + 'px;');\r\n        } else {\r\n          style.push('width:' + this.width_ + 'px; text-align:center;');\r\n        }\r\n      } else {\r\n        style.push('height:' + this.height_ + 'px; line-height:' +\r\n            this.height_ + 'px; width:' + this.width_ + 'px; text-align:center;');\r\n      }\r\n\r\n      var txtColor = this.textColor_ ? this.textColor_ : 'black';\r\n      var txtSize = this.textSize_ ? this.textSize_ : 11;\r\n\r\n      style.push('cursor:pointer; color:' + txtColor + '; position:absolute; font-size:' +\r\n          txtSize + 'px; font-family:Arial,sans-serif; font-weight:bold');\r\n    }\r\n    else {\r\n      style.push('top:' + pos.y + 'px; left:' +\r\n          pos.x + 'px;');\r\n    }\r\n    return style.join('');\r\n  };\r\n\r\n\r\n  // Export Symbols for Closure\r\n  // If you are not going to compile with closure then you can remove the\r\n  // code below.\r\n  window['MarkerClusterer'] = MarkerClusterer;\r\n  MarkerClusterer.prototype['addMarker'] = MarkerClusterer.prototype.addMarker;\r\n  MarkerClusterer.prototype['addMarkers'] = MarkerClusterer.prototype.addMarkers;\r\n  MarkerClusterer.prototype['clearMarkers'] =\r\n      MarkerClusterer.prototype.clearMarkers;\r\n  MarkerClusterer.prototype['fitMapToMarkers'] =\r\n      MarkerClusterer.prototype.fitMapToMarkers;\r\n  MarkerClusterer.prototype['getCalculator'] =\r\n      MarkerClusterer.prototype.getCalculator;\r\n  MarkerClusterer.prototype['getGridSize'] =\r\n      MarkerClusterer.prototype.getGridSize;\r\n  MarkerClusterer.prototype['getExtendedBounds'] =\r\n      MarkerClusterer.prototype.getExtendedBounds;\r\n  MarkerClusterer.prototype['getMap'] = MarkerClusterer.prototype.getMap;\r\n  MarkerClusterer.prototype['getMarkers'] = MarkerClusterer.prototype.getMarkers;\r\n  MarkerClusterer.prototype['getMaxZoom'] = MarkerClusterer.prototype.getMaxZoom;\r\n  MarkerClusterer.prototype['getStyles'] = MarkerClusterer.prototype.getStyles;\r\n  MarkerClusterer.prototype['getTotalClusters'] =\r\n      MarkerClusterer.prototype.getTotalClusters;\r\n  MarkerClusterer.prototype['getTotalMarkers'] =\r\n      MarkerClusterer.prototype.getTotalMarkers;\r\n  MarkerClusterer.prototype['redraw'] = MarkerClusterer.prototype.redraw;\r\n  MarkerClusterer.prototype['removeMarker'] =\r\n      MarkerClusterer.prototype.removeMarker;\r\n  MarkerClusterer.prototype['removeMarkers'] =\r\n      MarkerClusterer.prototype.removeMarkers;\r\n  MarkerClusterer.prototype['resetViewport'] =\r\n      MarkerClusterer.prototype.resetViewport;\r\n  MarkerClusterer.prototype['repaint'] =\r\n      MarkerClusterer.prototype.repaint;\r\n  MarkerClusterer.prototype['setCalculator'] =\r\n      MarkerClusterer.prototype.setCalculator;\r\n  MarkerClusterer.prototype['setGridSize'] =\r\n      MarkerClusterer.prototype.setGridSize;\r\n  MarkerClusterer.prototype['setMaxZoom'] =\r\n      MarkerClusterer.prototype.setMaxZoom;\r\n  MarkerClusterer.prototype['onAdd'] = MarkerClusterer.prototype.onAdd;\r\n  MarkerClusterer.prototype['draw'] = MarkerClusterer.prototype.draw;\r\n\r\n  Cluster.prototype['getCenter'] = Cluster.prototype.getCenter;\r\n  Cluster.prototype['getSize'] = Cluster.prototype.getSize;\r\n  Cluster.prototype['getMarkers'] = Cluster.prototype.getMarkers;\r\n\r\n  ClusterIcon.prototype['onAdd'] = ClusterIcon.prototype.onAdd;\r\n  ClusterIcon.prototype['draw'] = ClusterIcon.prototype.draw;\r\n  ClusterIcon.prototype['onRemove'] = ClusterIcon.prototype.onRemove;"],"sourceRoot":""}